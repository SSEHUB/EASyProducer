/*
 * generated by Xtext 2.35.0
 */
package de.uni_hildesheim.sse.serializer;

import com.google.inject.Inject;
import de.uni_hildesheim.sse.ivml.AccessName;
import de.uni_hildesheim.sse.ivml.ActualArgument;
import de.uni_hildesheim.sse.ivml.AdditiveExpression;
import de.uni_hildesheim.sse.ivml.AdditiveExpressionPart;
import de.uni_hildesheim.sse.ivml.AnnotateTo;
import de.uni_hildesheim.sse.ivml.AnnotationDeclarations;
import de.uni_hildesheim.sse.ivml.AssignmentExpression;
import de.uni_hildesheim.sse.ivml.AssignmentExpressionPart;
import de.uni_hildesheim.sse.ivml.AttrAssignment;
import de.uni_hildesheim.sse.ivml.AttrAssignmentPart;
import de.uni_hildesheim.sse.ivml.BasicType;
import de.uni_hildesheim.sse.ivml.BlockExpression;
import de.uni_hildesheim.sse.ivml.Call;
import de.uni_hildesheim.sse.ivml.ConflictStmt;
import de.uni_hildesheim.sse.ivml.ContainerInitializer;
import de.uni_hildesheim.sse.ivml.ContainerOp;
import de.uni_hildesheim.sse.ivml.Declaration;
import de.uni_hildesheim.sse.ivml.Declarator;
import de.uni_hildesheim.sse.ivml.DerivedType;
import de.uni_hildesheim.sse.ivml.EqualityExpression;
import de.uni_hildesheim.sse.ivml.EqualityExpressionPart;
import de.uni_hildesheim.sse.ivml.Eval;
import de.uni_hildesheim.sse.ivml.Export;
import de.uni_hildesheim.sse.ivml.Expression;
import de.uni_hildesheim.sse.ivml.ExpressionAccess;
import de.uni_hildesheim.sse.ivml.ExpressionListEntry;
import de.uni_hildesheim.sse.ivml.ExpressionListOrRange;
import de.uni_hildesheim.sse.ivml.ExpressionStatement;
import de.uni_hildesheim.sse.ivml.FeatureCall;
import de.uni_hildesheim.sse.ivml.Freeze;
import de.uni_hildesheim.sse.ivml.FreezeStatement;
import de.uni_hildesheim.sse.ivml.IfExpression;
import de.uni_hildesheim.sse.ivml.ImplicationExpression;
import de.uni_hildesheim.sse.ivml.ImplicationExpressionPart;
import de.uni_hildesheim.sse.ivml.ImportStmt;
import de.uni_hildesheim.sse.ivml.InterfaceDeclaration;
import de.uni_hildesheim.sse.ivml.IvmlPackage;
import de.uni_hildesheim.sse.ivml.LetExpression;
import de.uni_hildesheim.sse.ivml.Literal;
import de.uni_hildesheim.sse.ivml.LogicalExpression;
import de.uni_hildesheim.sse.ivml.LogicalExpressionPart;
import de.uni_hildesheim.sse.ivml.MultiplicativeExpression;
import de.uni_hildesheim.sse.ivml.MultiplicativeExpressionPart;
import de.uni_hildesheim.sse.ivml.NumValue;
import de.uni_hildesheim.sse.ivml.OpDefParameter;
import de.uni_hildesheim.sse.ivml.OpDefParameterList;
import de.uni_hildesheim.sse.ivml.OpDefStatement;
import de.uni_hildesheim.sse.ivml.OptBlockExpression;
import de.uni_hildesheim.sse.ivml.PostfixExpression;
import de.uni_hildesheim.sse.ivml.PrimaryExpression;
import de.uni_hildesheim.sse.ivml.Project;
import de.uni_hildesheim.sse.ivml.ProjectContents;
import de.uni_hildesheim.sse.ivml.QualifiedName;
import de.uni_hildesheim.sse.ivml.RelationalExpression;
import de.uni_hildesheim.sse.ivml.RelationalExpressionPart;
import de.uni_hildesheim.sse.ivml.Type;
import de.uni_hildesheim.sse.ivml.Typedef;
import de.uni_hildesheim.sse.ivml.TypedefCompound;
import de.uni_hildesheim.sse.ivml.TypedefConstraint;
import de.uni_hildesheim.sse.ivml.TypedefEnum;
import de.uni_hildesheim.sse.ivml.TypedefEnumLiteral;
import de.uni_hildesheim.sse.ivml.TypedefMapping;
import de.uni_hildesheim.sse.ivml.UnaryExpression;
import de.uni_hildesheim.sse.ivml.Value;
import de.uni_hildesheim.sse.ivml.VariabilityUnit;
import de.uni_hildesheim.sse.ivml.VariableDeclaration;
import de.uni_hildesheim.sse.ivml.VariableDeclarationPart;
import de.uni_hildesheim.sse.ivml.VersionStmt;
import de.uni_hildesheim.sse.services.IvmlGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class IvmlSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private IvmlGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == IvmlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case IvmlPackage.ACCESS_NAME:
				sequence_AccessName(context, (AccessName) semanticObject); 
				return; 
			case IvmlPackage.ACTUAL_ARGUMENT:
				sequence_ActualArgument(context, (ActualArgument) semanticObject); 
				return; 
			case IvmlPackage.ADDITIVE_EXPRESSION:
				sequence_AdditiveExpression(context, (AdditiveExpression) semanticObject); 
				return; 
			case IvmlPackage.ADDITIVE_EXPRESSION_PART:
				sequence_AdditiveExpressionPart(context, (AdditiveExpressionPart) semanticObject); 
				return; 
			case IvmlPackage.ANNOTATE_TO:
				sequence_AnnotateTo(context, (AnnotateTo) semanticObject); 
				return; 
			case IvmlPackage.ANNOTATION_DECLARATIONS:
				sequence_AnnotationDeclarations(context, (AnnotationDeclarations) semanticObject); 
				return; 
			case IvmlPackage.ASSIGNMENT_EXPRESSION:
				sequence_AssignmentExpression(context, (AssignmentExpression) semanticObject); 
				return; 
			case IvmlPackage.ASSIGNMENT_EXPRESSION_PART:
				sequence_AssignmentExpressionPart(context, (AssignmentExpressionPart) semanticObject); 
				return; 
			case IvmlPackage.ATTR_ASSIGNMENT:
				sequence_AttrAssignment(context, (AttrAssignment) semanticObject); 
				return; 
			case IvmlPackage.ATTR_ASSIGNMENT_PART:
				sequence_AttrAssignmentPart(context, (AttrAssignmentPart) semanticObject); 
				return; 
			case IvmlPackage.BASIC_TYPE:
				sequence_BasicType(context, (BasicType) semanticObject); 
				return; 
			case IvmlPackage.BLOCK_EXPRESSION:
				sequence_BlockExpression(context, (BlockExpression) semanticObject); 
				return; 
			case IvmlPackage.CALL:
				sequence_Call(context, (Call) semanticObject); 
				return; 
			case IvmlPackage.CONFLICT_STMT:
				sequence_ConflictStmt(context, (ConflictStmt) semanticObject); 
				return; 
			case IvmlPackage.CONTAINER_INITIALIZER:
				sequence_ContainerInitializer(context, (ContainerInitializer) semanticObject); 
				return; 
			case IvmlPackage.CONTAINER_OP:
				sequence_ActualArgumentList_ContainerOp(context, (ContainerOp) semanticObject); 
				return; 
			case IvmlPackage.DECLARATION:
				sequence_Declaration(context, (Declaration) semanticObject); 
				return; 
			case IvmlPackage.DECLARATOR:
				sequence_Declarator(context, (Declarator) semanticObject); 
				return; 
			case IvmlPackage.DERIVED_TYPE:
				sequence_DerivedType(context, (DerivedType) semanticObject); 
				return; 
			case IvmlPackage.EQUALITY_EXPRESSION:
				sequence_EqualityExpression(context, (EqualityExpression) semanticObject); 
				return; 
			case IvmlPackage.EQUALITY_EXPRESSION_PART:
				sequence_EqualityExpressionPart(context, (EqualityExpressionPart) semanticObject); 
				return; 
			case IvmlPackage.EVAL:
				sequence_Eval(context, (Eval) semanticObject); 
				return; 
			case IvmlPackage.EXPORT:
				sequence_Export(context, (Export) semanticObject); 
				return; 
			case IvmlPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case IvmlPackage.EXPRESSION_ACCESS:
				sequence_ExpressionAccess(context, (ExpressionAccess) semanticObject); 
				return; 
			case IvmlPackage.EXPRESSION_LIST_ENTRY:
				sequence_ExpressionListEntry(context, (ExpressionListEntry) semanticObject); 
				return; 
			case IvmlPackage.EXPRESSION_LIST_OR_RANGE:
				sequence_ExpressionListOrRange(context, (ExpressionListOrRange) semanticObject); 
				return; 
			case IvmlPackage.EXPRESSION_STATEMENT:
				sequence_ExpressionStatement(context, (ExpressionStatement) semanticObject); 
				return; 
			case IvmlPackage.FEATURE_CALL:
				sequence_ActualArgumentList_FeatureCall(context, (FeatureCall) semanticObject); 
				return; 
			case IvmlPackage.FREEZE:
				sequence_Freeze(context, (Freeze) semanticObject); 
				return; 
			case IvmlPackage.FREEZE_STATEMENT:
				sequence_FreezeStatement(context, (FreezeStatement) semanticObject); 
				return; 
			case IvmlPackage.IF_EXPRESSION:
				sequence_IfExpression(context, (IfExpression) semanticObject); 
				return; 
			case IvmlPackage.IMPLICATION_EXPRESSION:
				sequence_ImplicationExpression(context, (ImplicationExpression) semanticObject); 
				return; 
			case IvmlPackage.IMPLICATION_EXPRESSION_PART:
				sequence_ImplicationExpressionPart(context, (ImplicationExpressionPart) semanticObject); 
				return; 
			case IvmlPackage.IMPORT_STMT:
				sequence_ImportStmt(context, (ImportStmt) semanticObject); 
				return; 
			case IvmlPackage.INTERFACE_DECLARATION:
				sequence_InterfaceDeclaration(context, (InterfaceDeclaration) semanticObject); 
				return; 
			case IvmlPackage.LET_EXPRESSION:
				sequence_LetExpression(context, (LetExpression) semanticObject); 
				return; 
			case IvmlPackage.LITERAL:
				sequence_Literal(context, (Literal) semanticObject); 
				return; 
			case IvmlPackage.LOGICAL_EXPRESSION:
				sequence_LogicalExpression(context, (LogicalExpression) semanticObject); 
				return; 
			case IvmlPackage.LOGICAL_EXPRESSION_PART:
				sequence_LogicalExpressionPart(context, (LogicalExpressionPart) semanticObject); 
				return; 
			case IvmlPackage.MULTIPLICATIVE_EXPRESSION:
				sequence_MultiplicativeExpression(context, (MultiplicativeExpression) semanticObject); 
				return; 
			case IvmlPackage.MULTIPLICATIVE_EXPRESSION_PART:
				sequence_MultiplicativeExpressionPart(context, (MultiplicativeExpressionPart) semanticObject); 
				return; 
			case IvmlPackage.NUM_VALUE:
				sequence_NumValue(context, (NumValue) semanticObject); 
				return; 
			case IvmlPackage.OP_DEF_PARAMETER:
				sequence_OpDefParameter(context, (OpDefParameter) semanticObject); 
				return; 
			case IvmlPackage.OP_DEF_PARAMETER_LIST:
				sequence_OpDefParameterList(context, (OpDefParameterList) semanticObject); 
				return; 
			case IvmlPackage.OP_DEF_STATEMENT:
				sequence_OpDefStatement(context, (OpDefStatement) semanticObject); 
				return; 
			case IvmlPackage.OPT_BLOCK_EXPRESSION:
				sequence_OptBlockExpression(context, (OptBlockExpression) semanticObject); 
				return; 
			case IvmlPackage.POSTFIX_EXPRESSION:
				sequence_PostfixExpression(context, (PostfixExpression) semanticObject); 
				return; 
			case IvmlPackage.PRIMARY_EXPRESSION:
				sequence_PrimaryExpression(context, (PrimaryExpression) semanticObject); 
				return; 
			case IvmlPackage.PROJECT:
				sequence_Project(context, (Project) semanticObject); 
				return; 
			case IvmlPackage.PROJECT_CONTENTS:
				sequence_ProjectContents(context, (ProjectContents) semanticObject); 
				return; 
			case IvmlPackage.QUALIFIED_NAME:
				sequence_QualifiedName(context, (QualifiedName) semanticObject); 
				return; 
			case IvmlPackage.RELATIONAL_EXPRESSION:
				sequence_RelationalExpression(context, (RelationalExpression) semanticObject); 
				return; 
			case IvmlPackage.RELATIONAL_EXPRESSION_PART:
				sequence_RelationalExpressionPart(context, (RelationalExpressionPart) semanticObject); 
				return; 
			case IvmlPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case IvmlPackage.TYPEDEF:
				sequence_Typedef(context, (Typedef) semanticObject); 
				return; 
			case IvmlPackage.TYPEDEF_COMPOUND:
				sequence_TypedefCompound(context, (TypedefCompound) semanticObject); 
				return; 
			case IvmlPackage.TYPEDEF_CONSTRAINT:
				sequence_TypedefConstraint(context, (TypedefConstraint) semanticObject); 
				return; 
			case IvmlPackage.TYPEDEF_ENUM:
				sequence_TypedefEnum(context, (TypedefEnum) semanticObject); 
				return; 
			case IvmlPackage.TYPEDEF_ENUM_LITERAL:
				sequence_TypedefEnumLiteral(context, (TypedefEnumLiteral) semanticObject); 
				return; 
			case IvmlPackage.TYPEDEF_MAPPING:
				sequence_TypedefMapping(context, (TypedefMapping) semanticObject); 
				return; 
			case IvmlPackage.UNARY_EXPRESSION:
				sequence_UnaryExpression(context, (UnaryExpression) semanticObject); 
				return; 
			case IvmlPackage.VALUE:
				sequence_Value(context, (Value) semanticObject); 
				return; 
			case IvmlPackage.VARIABILITY_UNIT:
				sequence_VariabilityUnit(context, (VariabilityUnit) semanticObject); 
				return; 
			case IvmlPackage.VARIABLE_DECLARATION:
				sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
				return; 
			case IvmlPackage.VARIABLE_DECLARATION_PART:
				sequence_VariableDeclarationPart(context, (VariableDeclarationPart) semanticObject); 
				return; 
			case IvmlPackage.VERSION_STMT:
				sequence_VersionStmt(context, (VersionStmt) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     AccessName returns AccessName
	 *
	 * Constraint:
	 *     (aName+='.' aName+=Identifier)+
	 * </pre>
	 */
	protected void sequence_AccessName(ISerializationContext context, AccessName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContainerOp returns ContainerOp
	 *
	 * Constraint:
	 *     (name=Identifier decl=Declarator? (args+=ActualArgument args+=ActualArgument*)?)
	 * </pre>
	 */
	protected void sequence_ActualArgumentList_ContainerOp(ISerializationContext context, ContainerOp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FeatureCall returns FeatureCall
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             name=Identifier | 
	 *             name=RelationalOperator | 
	 *             name=AdditiveOperator | 
	 *             name=MultiplicativeOperator | 
	 *             name=EqualityOperator | 
	 *             name=ImplicationOperator | 
	 *             name=LogicalOperator | 
	 *             name='not'
	 *         ) 
	 *         (args+=ActualArgument args+=ActualArgument*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_ActualArgumentList_FeatureCall(ISerializationContext context, FeatureCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ActualArgument returns ActualArgument
	 *
	 * Constraint:
	 *     (name=Identifier? arg=Expression)
	 * </pre>
	 */
	protected void sequence_ActualArgument(ISerializationContext context, ActualArgument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AdditiveExpressionPart returns AdditiveExpressionPart
	 *
	 * Constraint:
	 *     (op=AdditiveOperator ex=MultiplicativeExpression)
	 * </pre>
	 */
	protected void sequence_AdditiveExpressionPart(ISerializationContext context, AdditiveExpressionPart semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IvmlPackage.Literals.ADDITIVE_EXPRESSION_PART__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IvmlPackage.Literals.ADDITIVE_EXPRESSION_PART__OP));
			if (transientValues.isValueTransient(semanticObject, IvmlPackage.Literals.ADDITIVE_EXPRESSION_PART__EX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IvmlPackage.Literals.ADDITIVE_EXPRESSION_PART__EX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditiveExpressionPartAccess().getOpAdditiveOperatorParserRuleCall_0_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getAdditiveExpressionPartAccess().getExMultiplicativeExpressionParserRuleCall_1_0(), semanticObject.getEx());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AdditiveExpression returns AdditiveExpression
	 *
	 * Constraint:
	 *     (left=MultiplicativeExpression right+=AdditiveExpressionPart*)
	 * </pre>
	 */
	protected void sequence_AdditiveExpression(ISerializationContext context, AdditiveExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnnotateTo returns AnnotateTo
	 *
	 * Constraint:
	 *     (
	 *         (sname='attribute' | sname='annotate') 
	 *         annotationType=Type 
	 *         annotationDecl=VariableDeclarationPart 
	 *         (names+='.' | (names+=Identifier names+=Identifier*))
	 *     )
	 * </pre>
	 */
	protected void sequence_AnnotateTo(ISerializationContext context, AnnotateTo semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnnotationDeclarations returns AnnotationDeclarations
	 *
	 * Constraint:
	 *     id+=Identifier*
	 * </pre>
	 */
	protected void sequence_AnnotationDeclarations(ISerializationContext context, AnnotationDeclarations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignmentExpressionPart returns AssignmentExpressionPart
	 *
	 * Constraint:
	 *     (op=AssignmentOperator (ex=LogicalExpression | container=ContainerInitializer))
	 * </pre>
	 */
	protected void sequence_AssignmentExpressionPart(ISerializationContext context, AssignmentExpressionPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignmentExpression returns AssignmentExpression
	 *
	 * Constraint:
	 *     (left=LogicalExpression right+=AssignmentExpressionPart?)
	 * </pre>
	 */
	protected void sequence_AssignmentExpression(ISerializationContext context, AssignmentExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttrAssignmentPart returns AttrAssignmentPart
	 *
	 * Constraint:
	 *     (name=Identifier value=LogicalExpression)
	 * </pre>
	 */
	protected void sequence_AttrAssignmentPart(ISerializationContext context, AttrAssignmentPart semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IvmlPackage.Literals.ATTR_ASSIGNMENT_PART__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IvmlPackage.Literals.ATTR_ASSIGNMENT_PART__NAME));
			if (transientValues.isValueTransient(semanticObject, IvmlPackage.Literals.ATTR_ASSIGNMENT_PART__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IvmlPackage.Literals.ATTR_ASSIGNMENT_PART__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttrAssignmentPartAccess().getNameIdentifierParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAttrAssignmentPartAccess().getValueLogicalExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttrAssignment returns AttrAssignment
	 *
	 * Constraint:
	 *     (
	 *         parts+=AttrAssignmentPart 
	 *         parts+=AttrAssignmentPart* 
	 *         (elements+=VariableDeclaration | elements+=ExpressionStatement | elements+=AttrAssignment)+
	 *     )
	 * </pre>
	 */
	protected void sequence_AttrAssignment(ISerializationContext context, AttrAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BasicType returns BasicType
	 *
	 * Constraint:
	 *     (
	 *         type='Integer' | 
	 *         type='Real' | 
	 *         type='Boolean' | 
	 *         type='String' | 
	 *         type='Constraint' | 
	 *         type='Any'
	 *     )
	 * </pre>
	 */
	protected void sequence_BasicType(ISerializationContext context, BasicType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BlockExpression returns BlockExpression
	 *
	 * Constraint:
	 *     exprs+=ExpressionStatement+
	 * </pre>
	 */
	protected void sequence_BlockExpression(ISerializationContext context, BlockExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Call returns Call
	 *
	 * Constraint:
	 *     (call=FeatureCall | containerOp=ContainerOp | arrayEx=Expression)
	 * </pre>
	 */
	protected void sequence_Call(ISerializationContext context, Call semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConflictStmt returns ConflictStmt
	 *
	 * Constraint:
	 *     (name=Identifier restriction=Expression?)
	 * </pre>
	 */
	protected void sequence_ConflictStmt(ISerializationContext context, ConflictStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContainerInitializer returns ContainerInitializer
	 *
	 * Constraint:
	 *     (type=QualifiedName? init=ExpressionListOrRange?)
	 * </pre>
	 */
	protected void sequence_ContainerInitializer(ISerializationContext context, ContainerInitializer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Declaration returns Declaration
	 *
	 * Constraint:
	 *     (type=Type? id+=Identifier id+=Identifier* init=Expression?)
	 * </pre>
	 */
	protected void sequence_Declaration(ISerializationContext context, Declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Declarator returns Declarator
	 *
	 * Constraint:
	 *     (decl+=Declaration decl+=Declaration*)
	 * </pre>
	 */
	protected void sequence_Declarator(ISerializationContext context, Declarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DerivedType returns DerivedType
	 *
	 * Constraint:
	 *     ((op='setOf' | op='sequenceOf' | op='refTo') type=Type)
	 * </pre>
	 */
	protected void sequence_DerivedType(ISerializationContext context, DerivedType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EqualityExpressionPart returns EqualityExpressionPart
	 *
	 * Constraint:
	 *     (op=EqualityOperator (ex=RelationalExpression | container=ContainerInitializer))
	 * </pre>
	 */
	protected void sequence_EqualityExpressionPart(ISerializationContext context, EqualityExpressionPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EqualityExpression returns EqualityExpression
	 *
	 * Constraint:
	 *     (left=RelationalExpression right=EqualityExpressionPart?)
	 * </pre>
	 */
	protected void sequence_EqualityExpression(ISerializationContext context, EqualityExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Eval returns Eval
	 *
	 * Constraint:
	 *     (nested+=Eval* statements+=ExpressionStatement*)
	 * </pre>
	 */
	protected void sequence_Eval(ISerializationContext context, Eval semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Export returns Export
	 *
	 * Constraint:
	 *     (names+=QualifiedName names+=QualifiedName*)
	 * </pre>
	 */
	protected void sequence_Export(ISerializationContext context, Export semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpressionAccess returns ExpressionAccess
	 *
	 * Constraint:
	 *     (name=Identifier calls+=Call* access=ExpressionAccess?)
	 * </pre>
	 */
	protected void sequence_ExpressionAccess(ISerializationContext context, ExpressionAccess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpressionListEntry returns ExpressionListEntry
	 *
	 * Constraint:
	 *     ((name=Identifier attrib=Identifier?)? (value=ImplicationExpression | container=ContainerInitializer))
	 * </pre>
	 */
	protected void sequence_ExpressionListEntry(ISerializationContext context, ExpressionListEntry semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpressionListOrRange returns ExpressionListOrRange
	 *
	 * Constraint:
	 *     (list+=ExpressionListEntry list+=ExpressionListEntry*)
	 * </pre>
	 */
	protected void sequence_ExpressionListOrRange(ISerializationContext context, ExpressionListOrRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpressionStatement returns ExpressionStatement
	 *
	 * Constraint:
	 *     expr=Expression
	 * </pre>
	 */
	protected void sequence_ExpressionStatement(ISerializationContext context, ExpressionStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IvmlPackage.Literals.EXPRESSION_STATEMENT__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IvmlPackage.Literals.EXPRESSION_STATEMENT__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionStatementAccess().getExprExpressionParserRuleCall_0_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Expression
	 *
	 * Constraint:
	 *     (let=LetExpression | expr=ImplicationExpression | container=ContainerInitializer)
	 * </pre>
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FreezeStatement returns FreezeStatement
	 *
	 * Constraint:
	 *     (dot='.' | (name=QualifiedName access=AccessName?))
	 * </pre>
	 */
	protected void sequence_FreezeStatement(ISerializationContext context, FreezeStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Freeze returns Freeze
	 *
	 * Constraint:
	 *     (names+=FreezeStatement+ (id=Identifier ex=LogicalExpression)?)
	 * </pre>
	 */
	protected void sequence_Freeze(ISerializationContext context, Freeze semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfExpression returns IfExpression
	 *
	 * Constraint:
	 *     (ifEx=Expression thenEx=OptBlockExpression elseEx=OptBlockExpression)
	 * </pre>
	 */
	protected void sequence_IfExpression(ISerializationContext context, IfExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IvmlPackage.Literals.IF_EXPRESSION__IF_EX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IvmlPackage.Literals.IF_EXPRESSION__IF_EX));
			if (transientValues.isValueTransient(semanticObject, IvmlPackage.Literals.IF_EXPRESSION__THEN_EX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IvmlPackage.Literals.IF_EXPRESSION__THEN_EX));
			if (transientValues.isValueTransient(semanticObject, IvmlPackage.Literals.IF_EXPRESSION__ELSE_EX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IvmlPackage.Literals.IF_EXPRESSION__ELSE_EX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfExpressionAccess().getIfExExpressionParserRuleCall_1_0(), semanticObject.getIfEx());
		feeder.accept(grammarAccess.getIfExpressionAccess().getThenExOptBlockExpressionParserRuleCall_3_0(), semanticObject.getThenEx());
		feeder.accept(grammarAccess.getIfExpressionAccess().getElseExOptBlockExpressionParserRuleCall_5_0(), semanticObject.getElseEx());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ImplicationExpressionPart returns ImplicationExpressionPart
	 *
	 * Constraint:
	 *     (op=ImplicationOperator ex=AssignmentExpression)
	 * </pre>
	 */
	protected void sequence_ImplicationExpressionPart(ISerializationContext context, ImplicationExpressionPart semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IvmlPackage.Literals.IMPLICATION_EXPRESSION_PART__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IvmlPackage.Literals.IMPLICATION_EXPRESSION_PART__OP));
			if (transientValues.isValueTransient(semanticObject, IvmlPackage.Literals.IMPLICATION_EXPRESSION_PART__EX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IvmlPackage.Literals.IMPLICATION_EXPRESSION_PART__EX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImplicationExpressionPartAccess().getOpImplicationOperatorParserRuleCall_0_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getImplicationExpressionPartAccess().getExAssignmentExpressionParserRuleCall_1_0(), semanticObject.getEx());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ImplicationExpression returns ImplicationExpression
	 *
	 * Constraint:
	 *     (left=AssignmentExpression right+=ImplicationExpressionPart*)
	 * </pre>
	 */
	protected void sequence_ImplicationExpression(ISerializationContext context, ImplicationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ImportStmt returns ImportStmt
	 *
	 * Constraint:
	 *     (insert='insert'? name=Identifier interface=Identifier? wildcard='*'? restriction=Expression?)
	 * </pre>
	 */
	protected void sequence_ImportStmt(ISerializationContext context, ImportStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InterfaceDeclaration returns InterfaceDeclaration
	 *
	 * Constraint:
	 *     (name=Identifier exports+=Export*)
	 * </pre>
	 */
	protected void sequence_InterfaceDeclaration(ISerializationContext context, InterfaceDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LetExpression returns LetExpression
	 *
	 * Constraint:
	 *     (type=Type name=Identifier valueExpr=Expression subExpr=OptBlockExpression)
	 * </pre>
	 */
	protected void sequence_LetExpression(ISerializationContext context, LetExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IvmlPackage.Literals.LET_EXPRESSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IvmlPackage.Literals.LET_EXPRESSION__TYPE));
			if (transientValues.isValueTransient(semanticObject, IvmlPackage.Literals.LET_EXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IvmlPackage.Literals.LET_EXPRESSION__NAME));
			if (transientValues.isValueTransient(semanticObject, IvmlPackage.Literals.LET_EXPRESSION__VALUE_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IvmlPackage.Literals.LET_EXPRESSION__VALUE_EXPR));
			if (transientValues.isValueTransient(semanticObject, IvmlPackage.Literals.LET_EXPRESSION__SUB_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IvmlPackage.Literals.LET_EXPRESSION__SUB_EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLetExpressionAccess().getTypeTypeParserRuleCall_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getLetExpressionAccess().getNameIdentifierParserRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLetExpressionAccess().getValueExprExpressionParserRuleCall_4_0(), semanticObject.getValueExpr());
		feeder.accept(grammarAccess.getLetExpressionAccess().getSubExprOptBlockExpressionParserRuleCall_6_0(), semanticObject.getSubExpr());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Literal returns Literal
	 *
	 * Constraint:
	 *     val=Value
	 * </pre>
	 */
	protected void sequence_Literal(ISerializationContext context, Literal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IvmlPackage.Literals.LITERAL__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IvmlPackage.Literals.LITERAL__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralAccess().getValValueParserRuleCall_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicalExpressionPart returns LogicalExpressionPart
	 *
	 * Constraint:
	 *     (op=LogicalOperator ex=EqualityExpression)
	 * </pre>
	 */
	protected void sequence_LogicalExpressionPart(ISerializationContext context, LogicalExpressionPart semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IvmlPackage.Literals.LOGICAL_EXPRESSION_PART__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IvmlPackage.Literals.LOGICAL_EXPRESSION_PART__OP));
			if (transientValues.isValueTransient(semanticObject, IvmlPackage.Literals.LOGICAL_EXPRESSION_PART__EX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IvmlPackage.Literals.LOGICAL_EXPRESSION_PART__EX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicalExpressionPartAccess().getOpLogicalOperatorParserRuleCall_0_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getLogicalExpressionPartAccess().getExEqualityExpressionParserRuleCall_1_0(), semanticObject.getEx());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicalExpression returns LogicalExpression
	 *
	 * Constraint:
	 *     (left=EqualityExpression right+=LogicalExpressionPart*)
	 * </pre>
	 */
	protected void sequence_LogicalExpression(ISerializationContext context, LogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MultiplicativeExpressionPart returns MultiplicativeExpressionPart
	 *
	 * Constraint:
	 *     (op=MultiplicativeOperator expr=UnaryExpression)
	 * </pre>
	 */
	protected void sequence_MultiplicativeExpressionPart(ISerializationContext context, MultiplicativeExpressionPart semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IvmlPackage.Literals.MULTIPLICATIVE_EXPRESSION_PART__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IvmlPackage.Literals.MULTIPLICATIVE_EXPRESSION_PART__OP));
			if (transientValues.isValueTransient(semanticObject, IvmlPackage.Literals.MULTIPLICATIVE_EXPRESSION_PART__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IvmlPackage.Literals.MULTIPLICATIVE_EXPRESSION_PART__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicativeExpressionPartAccess().getOpMultiplicativeOperatorParserRuleCall_0_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getMultiplicativeExpressionPartAccess().getExprUnaryExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MultiplicativeExpression returns MultiplicativeExpression
	 *
	 * Constraint:
	 *     (left=UnaryExpression right=MultiplicativeExpressionPart?)
	 * </pre>
	 */
	protected void sequence_MultiplicativeExpression(ISerializationContext context, MultiplicativeExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NumValue returns NumValue
	 *
	 * Constraint:
	 *     val=NUMBER
	 * </pre>
	 */
	protected void sequence_NumValue(ISerializationContext context, NumValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IvmlPackage.Literals.NUM_VALUE__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IvmlPackage.Literals.NUM_VALUE__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumValueAccess().getValNUMBERTerminalRuleCall_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OpDefParameterList returns OpDefParameterList
	 *
	 * Constraint:
	 *     (list+=OpDefParameter list+=OpDefParameter*)?
	 * </pre>
	 */
	protected void sequence_OpDefParameterList(ISerializationContext context, OpDefParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OpDefParameter returns OpDefParameter
	 *
	 * Constraint:
	 *     (type=Type id=Identifier val=Expression?)
	 * </pre>
	 */
	protected void sequence_OpDefParameter(ISerializationContext context, OpDefParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OpDefStatement returns OpDefStatement
	 *
	 * Constraint:
	 *     (
	 *         annotations=AnnotationDeclarations? 
	 *         static='static'? 
	 *         result=Type 
	 *         id=Identifier 
	 *         param=OpDefParameterList 
	 *         (impl=Expression | block=BlockExpression)
	 *     )
	 * </pre>
	 */
	protected void sequence_OpDefStatement(ISerializationContext context, OpDefStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OptBlockExpression returns OptBlockExpression
	 *
	 * Constraint:
	 *     (expr=Expression | block=BlockExpression)
	 * </pre>
	 */
	protected void sequence_OptBlockExpression(ISerializationContext context, OptBlockExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PostfixExpression returns PostfixExpression
	 *
	 * Constraint:
	 *     ((call=FeatureCall fCalls+=Call* access=ExpressionAccess?) | left=PrimaryExpression)
	 * </pre>
	 */
	protected void sequence_PostfixExpression(ISerializationContext context, PostfixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PrimaryExpression returns PrimaryExpression
	 *
	 * Constraint:
	 *     ((lit=Literal | ex=Expression | ifEx=IfExpression | refEx=Expression) calls+=Call* access=ExpressionAccess?)
	 * </pre>
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, PrimaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProjectContents returns ProjectContents
	 *
	 * Constraint:
	 *     (
	 *         elements+=Typedef | 
	 *         elements+=VariableDeclaration | 
	 *         elements+=Freeze | 
	 *         elements+=Eval | 
	 *         elements+=ExpressionStatement | 
	 *         elements+=AnnotateTo | 
	 *         elements+=OpDefStatement | 
	 *         elements+=AttrAssignment
	 *     )*
	 * </pre>
	 */
	protected void sequence_ProjectContents(ISerializationContext context, ProjectContents semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Project returns Project
	 *
	 * Constraint:
	 *     (
	 *         name=Identifier 
	 *         version=VersionStmt? 
	 *         imports+=ImportStmt* 
	 *         conflicts+=ConflictStmt* 
	 *         interfaces+=InterfaceDeclaration* 
	 *         contents=ProjectContents
	 *     )
	 * </pre>
	 */
	protected void sequence_Project(ISerializationContext context, Project semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     QualifiedName returns QualifiedName
	 *
	 * Constraint:
	 *     ((qName+=Identifier qName+='::' (qName+=Identifier qName+='::')*)? qName+=Identifier)
	 * </pre>
	 */
	protected void sequence_QualifiedName(ISerializationContext context, QualifiedName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RelationalExpressionPart returns RelationalExpressionPart
	 *
	 * Constraint:
	 *     (op=RelationalOperator ex=AdditiveExpression)
	 * </pre>
	 */
	protected void sequence_RelationalExpressionPart(ISerializationContext context, RelationalExpressionPart semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IvmlPackage.Literals.RELATIONAL_EXPRESSION_PART__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IvmlPackage.Literals.RELATIONAL_EXPRESSION_PART__OP));
			if (transientValues.isValueTransient(semanticObject, IvmlPackage.Literals.RELATIONAL_EXPRESSION_PART__EX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IvmlPackage.Literals.RELATIONAL_EXPRESSION_PART__EX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationalExpressionPartAccess().getOpRelationalOperatorParserRuleCall_0_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getRelationalExpressionPartAccess().getExAdditiveExpressionParserRuleCall_1_0(), semanticObject.getEx());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RelationalExpression returns RelationalExpression
	 *
	 * Constraint:
	 *     (left=AdditiveExpression (right=RelationalExpressionPart right2=RelationalExpressionPart?)?)
	 * </pre>
	 */
	protected void sequence_RelationalExpression(ISerializationContext context, RelationalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns Type
	 *
	 * Constraint:
	 *     (type=BasicType | id=QualifiedName | derived=DerivedType)
	 * </pre>
	 */
	protected void sequence_Type(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypedefCompound returns TypedefCompound
	 *
	 * Constraint:
	 *     (
	 *         abstract='abstract'? 
	 *         name=Identifier 
	 *         (super+=Identifier super+=Identifier*)? 
	 *         (elements+=VariableDeclaration | elements+=ExpressionStatement | elements+=AttrAssignment | elements+=Eval)*
	 *     )
	 * </pre>
	 */
	protected void sequence_TypedefCompound(ISerializationContext context, TypedefCompound semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypedefConstraint returns TypedefConstraint
	 *
	 * Constraint:
	 *     expressions=Expression
	 * </pre>
	 */
	protected void sequence_TypedefConstraint(ISerializationContext context, TypedefConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IvmlPackage.Literals.TYPEDEF_CONSTRAINT__EXPRESSIONS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IvmlPackage.Literals.TYPEDEF_CONSTRAINT__EXPRESSIONS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypedefConstraintAccess().getExpressionsExpressionParserRuleCall_2_0(), semanticObject.getExpressions());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypedefEnumLiteral returns TypedefEnumLiteral
	 *
	 * Constraint:
	 *     (name=Identifier value=NumValue?)
	 * </pre>
	 */
	protected void sequence_TypedefEnumLiteral(ISerializationContext context, TypedefEnumLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypedefEnum returns TypedefEnum
	 *
	 * Constraint:
	 *     (name=Identifier literals+=TypedefEnumLiteral literals+=TypedefEnumLiteral* constraint=TypedefConstraint?)
	 * </pre>
	 */
	protected void sequence_TypedefEnum(ISerializationContext context, TypedefEnum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypedefMapping returns TypedefMapping
	 *
	 * Constraint:
	 *     (newType=Identifier type=Type constraint=TypedefConstraint?)
	 * </pre>
	 */
	protected void sequence_TypedefMapping(ISerializationContext context, TypedefMapping semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Typedef returns Typedef
	 *
	 * Constraint:
	 *     (tEnum=TypedefEnum | tCompound=TypedefCompound | tMapping=TypedefMapping)
	 * </pre>
	 */
	protected void sequence_Typedef(ISerializationContext context, Typedef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UnaryExpression returns UnaryExpression
	 *
	 * Constraint:
	 *     (op=UnaryOperator? expr=PostfixExpression)
	 * </pre>
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, UnaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns Value
	 *
	 * Constraint:
	 *     (
	 *         nValue=NumValue | 
	 *         sValue=STRING | 
	 *         qValue=QualifiedName | 
	 *         bValue='true' | 
	 *         bValue='false' | 
	 *         self='self' | 
	 *         nullValue='null' | 
	 *         tValue=Type | 
	 *         version=VERSION
	 *     )
	 * </pre>
	 */
	protected void sequence_Value(ISerializationContext context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariabilityUnit returns VariabilityUnit
	 *
	 * Constraint:
	 *     projects+=Project*
	 * </pre>
	 */
	protected void sequence_VariabilityUnit(ISerializationContext context, VariabilityUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableDeclarationPart returns VariableDeclarationPart
	 *
	 * Constraint:
	 *     (name=Identifier default=Expression?)
	 * </pre>
	 */
	protected void sequence_VariableDeclarationPart(ISerializationContext context, VariableDeclarationPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableDeclaration returns VariableDeclaration
	 *
	 * Constraint:
	 *     (const='const'? type=Type decls+=VariableDeclarationPart decls+=VariableDeclarationPart*)
	 * </pre>
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, VariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VersionStmt returns VersionStmt
	 *
	 * Constraint:
	 *     version=VERSION
	 * </pre>
	 */
	protected void sequence_VersionStmt(ISerializationContext context, VersionStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IvmlPackage.Literals.VERSION_STMT__VERSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IvmlPackage.Literals.VERSION_STMT__VERSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVersionStmtAccess().getVersionVERSIONTerminalRuleCall_1_0(), semanticObject.getVersion());
		feeder.finish();
	}
	
	
}
