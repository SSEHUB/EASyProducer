/*
 * generated by Xtext 2.34.0
 */
package de.uni_hildesheim.sse.vil.buildlang.serializer;

import com.google.inject.Inject;
import de.uni_hildesheim.sse.vil.buildlang.services.VilBuildLanguageGrammarAccess;
import de.uni_hildesheim.sse.vil.buildlang.vilBuildLanguage.Alternative;
import de.uni_hildesheim.sse.vil.buildlang.vilBuildLanguage.ExpressionStatement;
import de.uni_hildesheim.sse.vil.buildlang.vilBuildLanguage.For;
import de.uni_hildesheim.sse.vil.buildlang.vilBuildLanguage.ImplementationUnit;
import de.uni_hildesheim.sse.vil.buildlang.vilBuildLanguage.Instantiate;
import de.uni_hildesheim.sse.vil.buildlang.vilBuildLanguage.Join;
import de.uni_hildesheim.sse.vil.buildlang.vilBuildLanguage.JoinVariable;
import de.uni_hildesheim.sse.vil.buildlang.vilBuildLanguage.LanguageUnit;
import de.uni_hildesheim.sse.vil.buildlang.vilBuildLanguage.LoadProperties;
import de.uni_hildesheim.sse.vil.buildlang.vilBuildLanguage.LoopVariable;
import de.uni_hildesheim.sse.vil.buildlang.vilBuildLanguage.Map;
import de.uni_hildesheim.sse.vil.buildlang.vilBuildLanguage.PrimaryExpression;
import de.uni_hildesheim.sse.vil.buildlang.vilBuildLanguage.Require;
import de.uni_hildesheim.sse.vil.buildlang.vilBuildLanguage.RuleConditions;
import de.uni_hildesheim.sse.vil.buildlang.vilBuildLanguage.RuleDeclaration;
import de.uni_hildesheim.sse.vil.buildlang.vilBuildLanguage.RuleElement;
import de.uni_hildesheim.sse.vil.buildlang.vilBuildLanguage.RuleElementBlock;
import de.uni_hildesheim.sse.vil.buildlang.vilBuildLanguage.RuleModifier;
import de.uni_hildesheim.sse.vil.buildlang.vilBuildLanguage.ScriptContents;
import de.uni_hildesheim.sse.vil.buildlang.vilBuildLanguage.ScriptParentDecl;
import de.uni_hildesheim.sse.vil.buildlang.vilBuildLanguage.StatementOrBlock;
import de.uni_hildesheim.sse.vil.buildlang.vilBuildLanguage.SystemExecution;
import de.uni_hildesheim.sse.vil.buildlang.vilBuildLanguage.VilBuildLanguagePackage;
import de.uni_hildesheim.sse.vil.buildlang.vilBuildLanguage.While;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.AdditiveExpression;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.AdditiveExpressionPart;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.Advice;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.AnnotationDeclarations;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.ArgumentList;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.Call;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.Compound;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.Constant;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.ConstructorExecution;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.ContainerInitializer;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.ContainerInitializerExpression;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.Declaration;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.DeclarationUnit;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.Declarator;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.EqualityExpression;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.EqualityExpressionPart;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.Expression;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.ExpressionDslPackage;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.ExpressionOrQualifiedExecution;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.Import;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.LogicalExpression;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.LogicalExpressionPart;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.MultiplicativeExpression;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.MultiplicativeExpressionPart;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.NamedArgument;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.NumValue;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.ParameterList;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.PostfixExpression;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.QualifiedName;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.QualifiedPrefix;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.RelationalExpression;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.RelationalExpressionPart;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.SubCall;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.SuperExecution;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.Type;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.TypeDef;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.TypeParameters;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.UnaryExpression;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.UnqualifiedExecution;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.VariableDeclaration;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.VersionSpec;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.VersionStmt;
import de.uni_hildesheim.sse.vil.expressions.serializer.ExpressionDslSemanticSequencer;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class VilBuildLanguageSemanticSequencer extends ExpressionDslSemanticSequencer {

	@Inject
	private VilBuildLanguageGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ExpressionDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ExpressionDslPackage.ADDITIVE_EXPRESSION:
				sequence_AdditiveExpression(context, (AdditiveExpression) semanticObject); 
				return; 
			case ExpressionDslPackage.ADDITIVE_EXPRESSION_PART:
				sequence_AdditiveExpressionPart(context, (AdditiveExpressionPart) semanticObject); 
				return; 
			case ExpressionDslPackage.ADVICE:
				sequence_Advice(context, (Advice) semanticObject); 
				return; 
			case ExpressionDslPackage.ANNOTATION_DECLARATIONS:
				sequence_AnnotationDeclarations(context, (AnnotationDeclarations) semanticObject); 
				return; 
			case ExpressionDslPackage.ARGUMENT_LIST:
				sequence_ArgumentList(context, (ArgumentList) semanticObject); 
				return; 
			case ExpressionDslPackage.CALL:
				sequence_Call(context, (Call) semanticObject); 
				return; 
			case ExpressionDslPackage.COMPOUND:
				sequence_Compound(context, (Compound) semanticObject); 
				return; 
			case ExpressionDslPackage.CONSTANT:
				sequence_Constant(context, (Constant) semanticObject); 
				return; 
			case ExpressionDslPackage.CONSTRUCTOR_EXECUTION:
				sequence_ConstructorExecution(context, (ConstructorExecution) semanticObject); 
				return; 
			case ExpressionDslPackage.CONTAINER_INITIALIZER:
				sequence_ContainerInitializer(context, (ContainerInitializer) semanticObject); 
				return; 
			case ExpressionDslPackage.CONTAINER_INITIALIZER_EXPRESSION:
				sequence_ContainerInitializerExpression(context, (ContainerInitializerExpression) semanticObject); 
				return; 
			case ExpressionDslPackage.DECLARATION:
				sequence_Declaration(context, (Declaration) semanticObject); 
				return; 
			case ExpressionDslPackage.DECLARATION_UNIT:
				sequence_DeclarationUnit(context, (DeclarationUnit) semanticObject); 
				return; 
			case ExpressionDslPackage.DECLARATOR:
				sequence_Declarator(context, (Declarator) semanticObject); 
				return; 
			case ExpressionDslPackage.EQUALITY_EXPRESSION:
				sequence_EqualityExpression(context, (EqualityExpression) semanticObject); 
				return; 
			case ExpressionDslPackage.EQUALITY_EXPRESSION_PART:
				sequence_EqualityExpressionPart(context, (EqualityExpressionPart) semanticObject); 
				return; 
			case ExpressionDslPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case ExpressionDslPackage.EXPRESSION_OR_QUALIFIED_EXECUTION:
				sequence_ExpressionOrQualifiedExecution(context, (ExpressionOrQualifiedExecution) semanticObject); 
				return; 
			case ExpressionDslPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case ExpressionDslPackage.LOGICAL_EXPRESSION:
				sequence_LogicalExpression(context, (LogicalExpression) semanticObject); 
				return; 
			case ExpressionDslPackage.LOGICAL_EXPRESSION_PART:
				sequence_LogicalExpressionPart(context, (LogicalExpressionPart) semanticObject); 
				return; 
			case ExpressionDslPackage.MULTIPLICATIVE_EXPRESSION:
				sequence_MultiplicativeExpression(context, (MultiplicativeExpression) semanticObject); 
				return; 
			case ExpressionDslPackage.MULTIPLICATIVE_EXPRESSION_PART:
				sequence_MultiplicativeExpressionPart(context, (MultiplicativeExpressionPart) semanticObject); 
				return; 
			case ExpressionDslPackage.NAMED_ARGUMENT:
				sequence_NamedArgument(context, (NamedArgument) semanticObject); 
				return; 
			case ExpressionDslPackage.NUM_VALUE:
				sequence_NumValue(context, (NumValue) semanticObject); 
				return; 
			case ExpressionDslPackage.PARAMETER:
				sequence_Parameter(context, (de.uni_hildesheim.sse.vil.expressions.expressionDsl.Parameter) semanticObject); 
				return; 
			case ExpressionDslPackage.PARAMETER_LIST:
				sequence_ParameterList(context, (ParameterList) semanticObject); 
				return; 
			case ExpressionDslPackage.POSTFIX_EXPRESSION:
				sequence_PostfixExpression(context, (PostfixExpression) semanticObject); 
				return; 
			case ExpressionDslPackage.QUALIFIED_NAME:
				sequence_QualifiedName(context, (QualifiedName) semanticObject); 
				return; 
			case ExpressionDslPackage.QUALIFIED_PREFIX:
				sequence_QualifiedPrefix(context, (QualifiedPrefix) semanticObject); 
				return; 
			case ExpressionDslPackage.RELATIONAL_EXPRESSION:
				sequence_RelationalExpression(context, (RelationalExpression) semanticObject); 
				return; 
			case ExpressionDslPackage.RELATIONAL_EXPRESSION_PART:
				sequence_RelationalExpressionPart(context, (RelationalExpressionPart) semanticObject); 
				return; 
			case ExpressionDslPackage.SUB_CALL:
				sequence_SubCall(context, (SubCall) semanticObject); 
				return; 
			case ExpressionDslPackage.SUPER_EXECUTION:
				sequence_SuperExecution(context, (SuperExecution) semanticObject); 
				return; 
			case ExpressionDslPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case ExpressionDslPackage.TYPE_DEF:
				sequence_TypeDef(context, (TypeDef) semanticObject); 
				return; 
			case ExpressionDslPackage.TYPE_PARAMETERS:
				sequence_TypeParameters(context, (TypeParameters) semanticObject); 
				return; 
			case ExpressionDslPackage.UNARY_EXPRESSION:
				sequence_UnaryExpression(context, (UnaryExpression) semanticObject); 
				return; 
			case ExpressionDslPackage.UNQUALIFIED_EXECUTION:
				sequence_UnqualifiedExecution(context, (UnqualifiedExecution) semanticObject); 
				return; 
			case ExpressionDslPackage.VARIABLE_DECLARATION:
				sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
				return; 
			case ExpressionDslPackage.VERSION_SPEC:
				sequence_VersionSpec(context, (VersionSpec) semanticObject); 
				return; 
			case ExpressionDslPackage.VERSION_STMT:
				sequence_VersionStmt(context, (VersionStmt) semanticObject); 
				return; 
			}
		else if (epackage == VilBuildLanguagePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case VilBuildLanguagePackage.ALTERNATIVE:
				sequence_Alternative(context, (Alternative) semanticObject); 
				return; 
			case VilBuildLanguagePackage.EXPRESSION_STATEMENT:
				sequence_ExpressionStatement(context, (ExpressionStatement) semanticObject); 
				return; 
			case VilBuildLanguagePackage.FOR:
				sequence_For(context, (For) semanticObject); 
				return; 
			case VilBuildLanguagePackage.IMPLEMENTATION_UNIT:
				sequence_ImplementationUnit(context, (ImplementationUnit) semanticObject); 
				return; 
			case VilBuildLanguagePackage.INSTANTIATE:
				sequence_Instantiate(context, (Instantiate) semanticObject); 
				return; 
			case VilBuildLanguagePackage.JOIN:
				sequence_Join(context, (Join) semanticObject); 
				return; 
			case VilBuildLanguagePackage.JOIN_VARIABLE:
				sequence_JoinVariable(context, (JoinVariable) semanticObject); 
				return; 
			case VilBuildLanguagePackage.LANGUAGE_UNIT:
				sequence_LanguageUnit(context, (LanguageUnit) semanticObject); 
				return; 
			case VilBuildLanguagePackage.LOAD_PROPERTIES:
				sequence_LoadProperties(context, (LoadProperties) semanticObject); 
				return; 
			case VilBuildLanguagePackage.LOOP_VARIABLE:
				sequence_LoopVariable(context, (LoopVariable) semanticObject); 
				return; 
			case VilBuildLanguagePackage.MAP:
				sequence_Map(context, (Map) semanticObject); 
				return; 
			case VilBuildLanguagePackage.PRIMARY_EXPRESSION:
				sequence_PrimaryExpression(context, (PrimaryExpression) semanticObject); 
				return; 
			case VilBuildLanguagePackage.REQUIRE:
				sequence_Require(context, (Require) semanticObject); 
				return; 
			case VilBuildLanguagePackage.RULE_CONDITIONS:
				sequence_RuleConditions(context, (RuleConditions) semanticObject); 
				return; 
			case VilBuildLanguagePackage.RULE_DECLARATION:
				sequence_RuleDeclaration(context, (RuleDeclaration) semanticObject); 
				return; 
			case VilBuildLanguagePackage.RULE_ELEMENT:
				sequence_RuleElement(context, (RuleElement) semanticObject); 
				return; 
			case VilBuildLanguagePackage.RULE_ELEMENT_BLOCK:
				sequence_RuleElementBlock(context, (RuleElementBlock) semanticObject); 
				return; 
			case VilBuildLanguagePackage.RULE_MODIFIER:
				sequence_RuleModifier(context, (RuleModifier) semanticObject); 
				return; 
			case VilBuildLanguagePackage.SCRIPT_CONTENTS:
				sequence_ScriptContents(context, (ScriptContents) semanticObject); 
				return; 
			case VilBuildLanguagePackage.SCRIPT_PARENT_DECL:
				sequence_ScriptParentDecl(context, (ScriptParentDecl) semanticObject); 
				return; 
			case VilBuildLanguagePackage.STATEMENT_OR_BLOCK:
				sequence_StatementOrBlock(context, (StatementOrBlock) semanticObject); 
				return; 
			case VilBuildLanguagePackage.SYSTEM_EXECUTION:
				sequence_SystemExecution(context, (SystemExecution) semanticObject); 
				return; 
			case VilBuildLanguagePackage.WHILE:
				sequence_While(context, (While) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Alternative returns Alternative
	 *
	 * Constraint:
	 *     (expr=Expression if=StatementOrBlock else=StatementOrBlock?)
	 * </pre>
	 */
	protected void sequence_Alternative(ISerializationContext context, Alternative semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpressionStatement returns ExpressionStatement
	 *
	 * Constraint:
	 *     (((var=Identifier field=Identifier?)? expr=Expression) | alt=Alternative)
	 * </pre>
	 */
	protected void sequence_ExpressionStatement(ISerializationContext context, ExpressionStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     For returns For
	 *
	 * Constraint:
	 *     (var+=LoopVariable var+=LoopVariable* (separator='=' | separator=':') expr=Expression block=RuleElementBlock)
	 * </pre>
	 */
	protected void sequence_For(ISerializationContext context, For semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ImplementationUnit returns ImplementationUnit
	 *
	 * Constraint:
	 *     (imports+=Import* requires+=Require* scripts+=LanguageUnit*)
	 * </pre>
	 */
	protected void sequence_ImplementationUnit(ISerializationContext context, ImplementationUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instantiate returns Instantiate
	 *
	 * Constraint:
	 *     ((project=Identifier | ruleName=STRING) param=ArgumentList? versionSpec=VersionSpec?)
	 * </pre>
	 */
	protected void sequence_Instantiate(ISerializationContext context, Instantiate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     JoinVariable returns JoinVariable
	 *
	 * Constraint:
	 *     (excl='exclude'? var=Identifier expr=Expression)
	 * </pre>
	 */
	protected void sequence_JoinVariable(ISerializationContext context, JoinVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Join returns Join
	 *
	 * Constraint:
	 *     (var1=JoinVariable var2=JoinVariable condition=Expression?)
	 * </pre>
	 */
	protected void sequence_Join(ISerializationContext context, Join semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LanguageUnit returns LanguageUnit
	 *
	 * Constraint:
	 *     (
	 *         advices+=Advice* 
	 *         name=Identifier 
	 *         param=ParameterList? 
	 *         parent=ScriptParentDecl? 
	 *         version=VersionStmt? 
	 *         loadProperties+=LoadProperties* 
	 *         contents=ScriptContents
	 *     )
	 * </pre>
	 */
	protected void sequence_LanguageUnit(ISerializationContext context, LanguageUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LoadProperties returns LoadProperties
	 *
	 * Constraint:
	 *     path=STRING
	 * </pre>
	 */
	protected void sequence_LoadProperties(ISerializationContext context, LoadProperties semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VilBuildLanguagePackage.Literals.LOAD_PROPERTIES__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VilBuildLanguagePackage.Literals.LOAD_PROPERTIES__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLoadPropertiesAccess().getPathSTRINGTerminalRuleCall_2_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LoopVariable returns LoopVariable
	 *
	 * Constraint:
	 *     (type=Type? var=Identifier)
	 * </pre>
	 */
	protected void sequence_LoopVariable(ISerializationContext context, LoopVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Map returns Map
	 *
	 * Constraint:
	 *     (var+=LoopVariable var+=LoopVariable* (separator='=' | separator=':') expr=Expression block=RuleElementBlock)
	 * </pre>
	 */
	protected void sequence_Map(ISerializationContext context, Map semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PrimaryExpression returns PrimaryExpression
	 *
	 * Constraint:
	 *     (
	 *         otherEx=ExpressionOrQualifiedExecution | 
	 *         unqEx=UnqualifiedExecution | 
	 *         superEx=SuperExecution | 
	 *         sysEx=SystemExecution | 
	 *         map=Map | 
	 *         join=Join | 
	 *         instantiate=Instantiate | 
	 *         newEx=ConstructorExecution
	 *     )
	 * </pre>
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, PrimaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Require returns Require
	 *
	 * Constraint:
	 *     (name=STRING versionSpec=VersionSpec)
	 * </pre>
	 */
	protected void sequence_Require(ISerializationContext context, Require semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VilBuildLanguagePackage.Literals.REQUIRE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VilBuildLanguagePackage.Literals.REQUIRE__NAME));
			if (transientValues.isValueTransient(semanticObject, VilBuildLanguagePackage.Literals.REQUIRE__VERSION_SPEC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VilBuildLanguagePackage.Literals.REQUIRE__VERSION_SPEC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRequireAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getRequireAccess().getVersionSpecVersionSpecParserRuleCall_2_0(), semanticObject.getVersionSpec());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RuleConditions returns RuleConditions
	 *
	 * Constraint:
	 *     (postcondition+=LogicalExpression? (preconditions+=LogicalExpression preconditions+=LogicalExpression*)?)
	 * </pre>
	 */
	protected void sequence_RuleConditions(ISerializationContext context, RuleConditions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RuleDeclaration returns RuleDeclaration
	 *
	 * Constraint:
	 *     (
	 *         (annotations=AnnotationDeclarations? modifier=RuleModifier? type=Type? name=Identifier paramList=ParameterList?)? 
	 *         conditions=RuleConditions? 
	 *         block=RuleElementBlock
	 *     )
	 * </pre>
	 */
	protected void sequence_RuleDeclaration(ISerializationContext context, RuleDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RuleElementBlock returns RuleElementBlock
	 *
	 * Constraint:
	 *     elements+=RuleElement*
	 * </pre>
	 */
	protected void sequence_RuleElementBlock(ISerializationContext context, RuleElementBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RuleElement returns RuleElement
	 *
	 * Constraint:
	 *     (varDecl=VariableDeclaration | exprStmt=ExpressionStatement | while=While | for=For)
	 * </pre>
	 */
	protected void sequence_RuleElement(ISerializationContext context, RuleElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RuleModifier returns RuleModifier
	 *
	 * Constraint:
	 *     protected='protected'
	 * </pre>
	 */
	protected void sequence_RuleModifier(ISerializationContext context, RuleModifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VilBuildLanguagePackage.Literals.RULE_MODIFIER__PROTECTED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VilBuildLanguagePackage.Literals.RULE_MODIFIER__PROTECTED));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRuleModifierAccess().getProtectedProtectedKeyword_0(), semanticObject.getProtected());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ScriptContents returns ScriptContents
	 *
	 * Constraint:
	 *     (elements+=VariableDeclaration | elements+=Compound | elements+=TypeDef | elements+=RuleDeclaration)*
	 * </pre>
	 */
	protected void sequence_ScriptContents(ISerializationContext context, ScriptContents semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ScriptParentDecl returns ScriptParentDecl
	 *
	 * Constraint:
	 *     name=Identifier
	 * </pre>
	 */
	protected void sequence_ScriptParentDecl(ISerializationContext context, ScriptParentDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VilBuildLanguagePackage.Literals.SCRIPT_PARENT_DECL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VilBuildLanguagePackage.Literals.SCRIPT_PARENT_DECL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScriptParentDeclAccess().getNameIdentifierParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StatementOrBlock returns StatementOrBlock
	 *
	 * Constraint:
	 *     (exStmt=ExpressionStatement | block=RuleElementBlock)
	 * </pre>
	 */
	protected void sequence_StatementOrBlock(ISerializationContext context, StatementOrBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SystemExecution returns SystemExecution
	 *
	 * Constraint:
	 *     (call=Call calls+=SubCall*)
	 * </pre>
	 */
	protected void sequence_SystemExecution(ISerializationContext context, SystemExecution semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     While returns While
	 *
	 * Constraint:
	 *     (expr=Expression block=RuleElementBlock)
	 * </pre>
	 */
	protected void sequence_While(ISerializationContext context, While semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VilBuildLanguagePackage.Literals.WHILE__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VilBuildLanguagePackage.Literals.WHILE__EXPR));
			if (transientValues.isValueTransient(semanticObject, VilBuildLanguagePackage.Literals.WHILE__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VilBuildLanguagePackage.Literals.WHILE__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileAccess().getExprExpressionParserRuleCall_2_0(), semanticObject.getExpr());
		feeder.accept(grammarAccess.getWhileAccess().getBlockRuleElementBlockParserRuleCall_4_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
}
