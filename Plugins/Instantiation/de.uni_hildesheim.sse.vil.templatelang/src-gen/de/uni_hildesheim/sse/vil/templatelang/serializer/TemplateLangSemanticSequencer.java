/*
 * generated by Xtext
 */
package de.uni_hildesheim.sse.vil.templatelang.serializer;

import com.google.inject.Inject;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.AdditiveExpression;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.AdditiveExpressionPart;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.Advice;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.ArgumentList;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.Call;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.Compound;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.Constant;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.ConstructorExecution;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.ContainerInitializer;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.ContainerInitializerExpression;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.Declaration;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.DeclarationUnit;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.Declarator;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.EqualityExpression;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.EqualityExpressionPart;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.Expression;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.ExpressionDslPackage;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.ExpressionOrQualifiedExecution;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.ExpressionStatement;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.Import;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.LogicalExpression;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.LogicalExpressionPart;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.MultiplicativeExpression;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.MultiplicativeExpressionPart;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.NamedArgument;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.NumValue;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.ParameterList;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.PostfixExpression;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.PrimaryExpression;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.QualifiedName;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.QualifiedPrefix;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.RelationalExpression;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.RelationalExpressionPart;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.SubCall;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.SuperExecution;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.Type;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.TypeDef;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.TypeParameters;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.UnaryExpression;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.UnqualifiedExecution;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.VariableDeclaration;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.VersionSpec;
import de.uni_hildesheim.sse.vil.expressions.expressionDsl.VersionStmt;
import de.uni_hildesheim.sse.vil.expressions.serializer.ExpressionDslSemanticSequencer;
import de.uni_hildesheim.sse.vil.templatelang.services.TemplateLangGrammarAccess;
import de.uni_hildesheim.sse.vil.templatelang.templateLang.Alternative;
import de.uni_hildesheim.sse.vil.templatelang.templateLang.Content;
import de.uni_hildesheim.sse.vil.templatelang.templateLang.Extension;
import de.uni_hildesheim.sse.vil.templatelang.templateLang.FormattingHint;
import de.uni_hildesheim.sse.vil.templatelang.templateLang.FormattingHintPart;
import de.uni_hildesheim.sse.vil.templatelang.templateLang.HintedExpression;
import de.uni_hildesheim.sse.vil.templatelang.templateLang.IndentationHint;
import de.uni_hildesheim.sse.vil.templatelang.templateLang.IndentationHintPart;
import de.uni_hildesheim.sse.vil.templatelang.templateLang.JavaQualifiedName;
import de.uni_hildesheim.sse.vil.templatelang.templateLang.LanguageUnit;
import de.uni_hildesheim.sse.vil.templatelang.templateLang.Loop;
import de.uni_hildesheim.sse.vil.templatelang.templateLang.Stmt;
import de.uni_hildesheim.sse.vil.templatelang.templateLang.StmtBlock;
import de.uni_hildesheim.sse.vil.templatelang.templateLang.Switch;
import de.uni_hildesheim.sse.vil.templatelang.templateLang.SwitchPart;
import de.uni_hildesheim.sse.vil.templatelang.templateLang.TemplateLangPackage;
import de.uni_hildesheim.sse.vil.templatelang.templateLang.Top;
import de.uni_hildesheim.sse.vil.templatelang.templateLang.VilDef;
import de.uni_hildesheim.sse.vil.templatelang.templateLang.While;
import de.uni_hildesheim.sse.vil.templatelang.templateLang.genericMultiselect;
import de.uni_hildesheim.sse.vil.templatelang.templateLang.multiSelectPart;
import de.uni_hildesheim.sse.vil.templatelang.templateLang.multiselect;
import de.uni_hildesheim.sse.vil.templatelang.templateLang.userMultiselect;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class TemplateLangSemanticSequencer extends ExpressionDslSemanticSequencer {

	@Inject
	private TemplateLangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ExpressionDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ExpressionDslPackage.ADDITIVE_EXPRESSION:
				sequence_AdditiveExpression(context, (AdditiveExpression) semanticObject); 
				return; 
			case ExpressionDslPackage.ADDITIVE_EXPRESSION_PART:
				sequence_AdditiveExpressionPart(context, (AdditiveExpressionPart) semanticObject); 
				return; 
			case ExpressionDslPackage.ADVICE:
				sequence_Advice(context, (Advice) semanticObject); 
				return; 
			case ExpressionDslPackage.ARGUMENT_LIST:
				sequence_ArgumentList(context, (ArgumentList) semanticObject); 
				return; 
			case ExpressionDslPackage.CALL:
				sequence_Call(context, (Call) semanticObject); 
				return; 
			case ExpressionDslPackage.COMPOUND:
				sequence_Compound(context, (Compound) semanticObject); 
				return; 
			case ExpressionDslPackage.CONSTANT:
				sequence_Constant(context, (Constant) semanticObject); 
				return; 
			case ExpressionDslPackage.CONSTRUCTOR_EXECUTION:
				sequence_ConstructorExecution(context, (ConstructorExecution) semanticObject); 
				return; 
			case ExpressionDslPackage.CONTAINER_INITIALIZER:
				sequence_ContainerInitializer(context, (ContainerInitializer) semanticObject); 
				return; 
			case ExpressionDslPackage.CONTAINER_INITIALIZER_EXPRESSION:
				sequence_ContainerInitializerExpression(context, (ContainerInitializerExpression) semanticObject); 
				return; 
			case ExpressionDslPackage.DECLARATION:
				sequence_Declaration(context, (Declaration) semanticObject); 
				return; 
			case ExpressionDslPackage.DECLARATION_UNIT:
				sequence_DeclarationUnit(context, (DeclarationUnit) semanticObject); 
				return; 
			case ExpressionDslPackage.DECLARATOR:
				sequence_Declarator(context, (Declarator) semanticObject); 
				return; 
			case ExpressionDslPackage.EQUALITY_EXPRESSION:
				sequence_EqualityExpression(context, (EqualityExpression) semanticObject); 
				return; 
			case ExpressionDslPackage.EQUALITY_EXPRESSION_PART:
				sequence_EqualityExpressionPart(context, (EqualityExpressionPart) semanticObject); 
				return; 
			case ExpressionDslPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case ExpressionDslPackage.EXPRESSION_OR_QUALIFIED_EXECUTION:
				sequence_ExpressionOrQualifiedExecution(context, (ExpressionOrQualifiedExecution) semanticObject); 
				return; 
			case ExpressionDslPackage.EXPRESSION_STATEMENT:
				sequence_ExpressionStatement(context, (ExpressionStatement) semanticObject); 
				return; 
			case ExpressionDslPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case ExpressionDslPackage.LOGICAL_EXPRESSION:
				sequence_LogicalExpression(context, (LogicalExpression) semanticObject); 
				return; 
			case ExpressionDslPackage.LOGICAL_EXPRESSION_PART:
				sequence_LogicalExpressionPart(context, (LogicalExpressionPart) semanticObject); 
				return; 
			case ExpressionDslPackage.MULTIPLICATIVE_EXPRESSION:
				sequence_MultiplicativeExpression(context, (MultiplicativeExpression) semanticObject); 
				return; 
			case ExpressionDslPackage.MULTIPLICATIVE_EXPRESSION_PART:
				sequence_MultiplicativeExpressionPart(context, (MultiplicativeExpressionPart) semanticObject); 
				return; 
			case ExpressionDslPackage.NAMED_ARGUMENT:
				sequence_NamedArgument(context, (NamedArgument) semanticObject); 
				return; 
			case ExpressionDslPackage.NUM_VALUE:
				sequence_NumValue(context, (NumValue) semanticObject); 
				return; 
			case ExpressionDslPackage.PARAMETER:
				sequence_Parameter(context, (de.uni_hildesheim.sse.vil.expressions.expressionDsl.Parameter) semanticObject); 
				return; 
			case ExpressionDslPackage.PARAMETER_LIST:
				sequence_ParameterList(context, (ParameterList) semanticObject); 
				return; 
			case ExpressionDslPackage.POSTFIX_EXPRESSION:
				sequence_PostfixExpression(context, (PostfixExpression) semanticObject); 
				return; 
			case ExpressionDslPackage.PRIMARY_EXPRESSION:
				sequence_PrimaryExpression(context, (PrimaryExpression) semanticObject); 
				return; 
			case ExpressionDslPackage.QUALIFIED_NAME:
				sequence_QualifiedName(context, (QualifiedName) semanticObject); 
				return; 
			case ExpressionDslPackage.QUALIFIED_PREFIX:
				sequence_QualifiedPrefix(context, (QualifiedPrefix) semanticObject); 
				return; 
			case ExpressionDslPackage.RELATIONAL_EXPRESSION:
				sequence_RelationalExpression(context, (RelationalExpression) semanticObject); 
				return; 
			case ExpressionDslPackage.RELATIONAL_EXPRESSION_PART:
				sequence_RelationalExpressionPart(context, (RelationalExpressionPart) semanticObject); 
				return; 
			case ExpressionDslPackage.SUB_CALL:
				sequence_SubCall(context, (SubCall) semanticObject); 
				return; 
			case ExpressionDslPackage.SUPER_EXECUTION:
				sequence_SuperExecution(context, (SuperExecution) semanticObject); 
				return; 
			case ExpressionDslPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case ExpressionDslPackage.TYPE_DEF:
				sequence_TypeDef(context, (TypeDef) semanticObject); 
				return; 
			case ExpressionDslPackage.TYPE_PARAMETERS:
				sequence_TypeParameters(context, (TypeParameters) semanticObject); 
				return; 
			case ExpressionDslPackage.UNARY_EXPRESSION:
				sequence_UnaryExpression(context, (UnaryExpression) semanticObject); 
				return; 
			case ExpressionDslPackage.UNQUALIFIED_EXECUTION:
				sequence_UnqualifiedExecution(context, (UnqualifiedExecution) semanticObject); 
				return; 
			case ExpressionDslPackage.VARIABLE_DECLARATION:
				sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
				return; 
			case ExpressionDslPackage.VERSION_SPEC:
				sequence_VersionSpec(context, (VersionSpec) semanticObject); 
				return; 
			case ExpressionDslPackage.VERSION_STMT:
				sequence_VersionStmt(context, (VersionStmt) semanticObject); 
				return; 
			}
		else if (epackage == TemplateLangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TemplateLangPackage.ALTERNATIVE:
				sequence_Alternative(context, (Alternative) semanticObject); 
				return; 
			case TemplateLangPackage.CONTENT:
				sequence_Content(context, (Content) semanticObject); 
				return; 
			case TemplateLangPackage.EXTENSION:
				sequence_Extension(context, (Extension) semanticObject); 
				return; 
			case TemplateLangPackage.FORMATTING_HINT:
				sequence_FormattingHint(context, (FormattingHint) semanticObject); 
				return; 
			case TemplateLangPackage.FORMATTING_HINT_PART:
				sequence_FormattingHintPart(context, (FormattingHintPart) semanticObject); 
				return; 
			case TemplateLangPackage.HINTED_EXPRESSION:
				sequence_HintedExpression(context, (HintedExpression) semanticObject); 
				return; 
			case TemplateLangPackage.INDENTATION_HINT:
				sequence_IndentationHint(context, (IndentationHint) semanticObject); 
				return; 
			case TemplateLangPackage.INDENTATION_HINT_PART:
				sequence_IndentationHintPart(context, (IndentationHintPart) semanticObject); 
				return; 
			case TemplateLangPackage.JAVA_QUALIFIED_NAME:
				sequence_JavaQualifiedName(context, (JavaQualifiedName) semanticObject); 
				return; 
			case TemplateLangPackage.LANGUAGE_UNIT:
				sequence_LanguageUnit(context, (LanguageUnit) semanticObject); 
				return; 
			case TemplateLangPackage.LOOP:
				sequence_Loop(context, (Loop) semanticObject); 
				return; 
			case TemplateLangPackage.STMT:
				sequence_Stmt(context, (Stmt) semanticObject); 
				return; 
			case TemplateLangPackage.STMT_BLOCK:
				sequence_StmtBlock(context, (StmtBlock) semanticObject); 
				return; 
			case TemplateLangPackage.SWITCH:
				sequence_Switch(context, (Switch) semanticObject); 
				return; 
			case TemplateLangPackage.SWITCH_PART:
				sequence_SwitchPart(context, (SwitchPart) semanticObject); 
				return; 
			case TemplateLangPackage.TOP:
				sequence_Top(context, (Top) semanticObject); 
				return; 
			case TemplateLangPackage.VIL_DEF:
				sequence_VilDef(context, (VilDef) semanticObject); 
				return; 
			case TemplateLangPackage.WHILE:
				sequence_While(context, (While) semanticObject); 
				return; 
			case TemplateLangPackage.GENERIC_MULTISELECT:
				sequence_genericMultiselect(context, (genericMultiselect) semanticObject); 
				return; 
			case TemplateLangPackage.MULTI_SELECT_PART:
				sequence_multiSelectPart(context, (multiSelectPart) semanticObject); 
				return; 
			case TemplateLangPackage.MULTISELECT:
				sequence_multiselect(context, (multiselect) semanticObject); 
				return; 
			case TemplateLangPackage.USER_MULTISELECT:
				sequence_userMultiselect(context, (userMultiselect) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Alternative returns Alternative
	 *
	 * Constraint:
	 *     (expr=Expression (if=Stmt | ifBlock=StmtBlock) (else=Stmt | elseBlock=StmtBlock)?)
	 */
	protected void sequence_Alternative(ISerializationContext context, Alternative semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Content returns Content
	 *
	 * Constraint:
	 *     (ctn=STRING (noCR='!'? CR='<CR>')? indent=Expression?)
	 */
	protected void sequence_Content(ISerializationContext context, Content semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Extension returns Extension
	 *
	 * Constraint:
	 *     name=JavaQualifiedName
	 */
	protected void sequence_Extension(ISerializationContext context, Extension semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TemplateLangPackage.Literals.EXTENSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TemplateLangPackage.Literals.EXTENSION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExtensionAccess().getNameJavaQualifiedNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FormattingHintPart returns FormattingHintPart
	 *
	 * Constraint:
	 *     (name=Identifier value=STRING)
	 */
	protected void sequence_FormattingHintPart(ISerializationContext context, FormattingHintPart semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TemplateLangPackage.Literals.FORMATTING_HINT_PART__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TemplateLangPackage.Literals.FORMATTING_HINT_PART__NAME));
			if (transientValues.isValueTransient(semanticObject, TemplateLangPackage.Literals.FORMATTING_HINT_PART__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TemplateLangPackage.Literals.FORMATTING_HINT_PART__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFormattingHintPartAccess().getNameIdentifierParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFormattingHintPartAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FormattingHint returns FormattingHint
	 *
	 * Constraint:
	 *     (parts+=FormattingHintPart parts+=FormattingHintPart*)
	 */
	protected void sequence_FormattingHint(ISerializationContext context, FormattingHint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HintedExpression returns HintedExpression
	 *
	 * Constraint:
	 *     (ex=Expression (hint=ID | hint='<')?)
	 */
	protected void sequence_HintedExpression(ISerializationContext context, HintedExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IndentationHintPart returns IndentationHintPart
	 *
	 * Constraint:
	 *     (name=Identifier value=NUMBER)
	 */
	protected void sequence_IndentationHintPart(ISerializationContext context, IndentationHintPart semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TemplateLangPackage.Literals.INDENTATION_HINT_PART__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TemplateLangPackage.Literals.INDENTATION_HINT_PART__NAME));
			if (transientValues.isValueTransient(semanticObject, TemplateLangPackage.Literals.INDENTATION_HINT_PART__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TemplateLangPackage.Literals.INDENTATION_HINT_PART__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIndentationHintPartAccess().getNameIdentifierParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getIndentationHintPartAccess().getValueNUMBERTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IndentationHint returns IndentationHint
	 *
	 * Constraint:
	 *     (parts+=IndentationHintPart parts+=IndentationHintPart*)
	 */
	protected void sequence_IndentationHint(ISerializationContext context, IndentationHint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JavaQualifiedName returns JavaQualifiedName
	 *
	 * Constraint:
	 *     (qname+=Identifier (qname+='.' qname+=Identifier)*)
	 */
	protected void sequence_JavaQualifiedName(ISerializationContext context, JavaQualifiedName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LanguageUnit returns LanguageUnit
	 *
	 * Constraint:
	 *     (
	 *         imports+=Import* 
	 *         javaExts+=Extension* 
	 *         advices+=Advice* 
	 *         indent=IndentationHint? 
	 *         formatting=FormattingHint? 
	 *         name=Identifier 
	 *         param=ParameterList? 
	 *         ext=Identifier? 
	 *         version=VersionStmt? 
	 *         (elements+=TypeDef | elements+=Compound | elements+=VariableDeclaration | elements+=VilDef)*
	 *     )
	 */
	protected void sequence_LanguageUnit(ISerializationContext context, LanguageUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Loop returns Loop
	 *
	 * Constraint:
	 *     (type=Type id=Identifier expr=Expression (separator=PrimaryExpression finalSeparator=PrimaryExpression?)? (stmt=Stmt | block=StmtBlock))
	 */
	protected void sequence_Loop(ISerializationContext context, Loop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StmtBlock returns StmtBlock
	 *
	 * Constraint:
	 *     stmts+=Stmt*
	 */
	protected void sequence_StmtBlock(ISerializationContext context, StmtBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Stmt returns Stmt
	 *
	 * Constraint:
	 *     (
	 *         var=VariableDeclaration | 
	 *         alt=Alternative | 
	 *         switch=Switch | 
	 *         multi=multiselect | 
	 *         loop=Loop | 
	 *         while=While | 
	 *         exprStmt=ExpressionStatement | 
	 *         ctn=Content | 
	 *         flush=Flush
	 *     )
	 */
	protected void sequence_Stmt(ISerializationContext context, Stmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SwitchPart returns SwitchPart
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_SwitchPart(ISerializationContext context, SwitchPart semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TemplateLangPackage.Literals.SWITCH_PART__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TemplateLangPackage.Literals.SWITCH_PART__LEFT));
			if (transientValues.isValueTransient(semanticObject, TemplateLangPackage.Literals.SWITCH_PART__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TemplateLangPackage.Literals.SWITCH_PART__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSwitchPartAccess().getLeftExpressionParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSwitchPartAccess().getRightExpressionParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Switch returns Switch
	 *
	 * Constraint:
	 *     (expr=Expression parts+=SwitchPart parts+=SwitchPart* dflt=Expression?)
	 */
	protected void sequence_Switch(ISerializationContext context, Switch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Top returns Top
	 *
	 * Constraint:
	 *     ex=HintedExpression
	 */
	protected void sequence_Top(ISerializationContext context, Top semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TemplateLangPackage.Literals.TOP__EX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TemplateLangPackage.Literals.TOP__EX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTopAccess().getExHintedExpressionParserRuleCall_0(), semanticObject.getEx());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VilDef returns VilDef
	 *
	 * Constraint:
	 *     (protected='protected'? type=Type? id=Identifier param=ParameterList? stmts=StmtBlock)
	 */
	protected void sequence_VilDef(ISerializationContext context, VilDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     While returns While
	 *
	 * Constraint:
	 *     (expr=Expression (stmt=Stmt | block=StmtBlock))
	 */
	protected void sequence_While(ISerializationContext context, While semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     genericMultiselect returns genericMultiselect
	 *
	 * Constraint:
	 *     (preamble=StmtBlock selector=StmtBlock part+=multiSelectPart+ trailer=StmtBlock)
	 */
	protected void sequence_genericMultiselect(ISerializationContext context, genericMultiselect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     multiSelectPart returns multiSelectPart
	 *
	 * Constraint:
	 *     (case=Expression code=StmtBlock selector=StmtBlock)
	 */
	protected void sequence_multiSelectPart(ISerializationContext context, multiSelectPart semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TemplateLangPackage.Literals.MULTI_SELECT_PART__CASE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TemplateLangPackage.Literals.MULTI_SELECT_PART__CASE));
			if (transientValues.isValueTransient(semanticObject, TemplateLangPackage.Literals.MULTI_SELECT_PART__CODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TemplateLangPackage.Literals.MULTI_SELECT_PART__CODE));
			if (transientValues.isValueTransient(semanticObject, TemplateLangPackage.Literals.MULTI_SELECT_PART__SELECTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TemplateLangPackage.Literals.MULTI_SELECT_PART__SELECTOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiSelectPartAccess().getCaseExpressionParserRuleCall_1_0(), semanticObject.getCase());
		feeder.accept(grammarAccess.getMultiSelectPartAccess().getCodeStmtBlockParserRuleCall_2_0(), semanticObject.getCode());
		feeder.accept(grammarAccess.getMultiSelectPartAccess().getSelectorStmtBlockParserRuleCall_3_0(), semanticObject.getSelector());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     multiselect returns multiselect
	 *
	 * Constraint:
	 *     (gen=genericMultiselect | user=userMultiselect)
	 */
	protected void sequence_multiselect(ISerializationContext context, multiselect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     userMultiselect returns userMultiselect
	 *
	 * Constraint:
	 *     (id=Identifier stmt=StmtBlock)
	 */
	protected void sequence_userMultiselect(ISerializationContext context, userMultiselect semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TemplateLangPackage.Literals.USER_MULTISELECT__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TemplateLangPackage.Literals.USER_MULTISELECT__ID));
			if (transientValues.isValueTransient(semanticObject, TemplateLangPackage.Literals.USER_MULTISELECT__STMT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TemplateLangPackage.Literals.USER_MULTISELECT__STMT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUserMultiselectAccess().getIdIdentifierParserRuleCall_0_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getUserMultiselectAccess().getStmtStmtBlockParserRuleCall_3_0(), semanticObject.getStmt());
		feeder.finish();
	}
	
	
}
