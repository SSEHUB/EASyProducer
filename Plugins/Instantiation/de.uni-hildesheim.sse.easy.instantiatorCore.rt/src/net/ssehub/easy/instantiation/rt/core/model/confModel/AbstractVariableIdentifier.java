/*
 * Copyright 2009-2016 University of Hildesheim, Software Systems Engineering
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.ssehub.easy.instantiation.rt.core.model.confModel;

import java.util.Iterator;

import net.ssehub.easy.varModel.confModel.AssignmentState;
import net.ssehub.easy.varModel.confModel.ConfigurationException;
import net.ssehub.easy.varModel.confModel.IDecisionVariable;
import net.ssehub.easy.varModel.model.values.Value;
import net.ssehub.easy.varModel.model.values.ValueDoesNotMatchTypeException;

/**
 * Allows flexible handling of different identifier systems for referencing variable in the
 * {@link AdaptiveConfiguration}.
 * @param <V> specifies which kind of classes are used to reference
 * {@link net.ssehub.easy.varModel.confModel.IDecisionVariable}s before the values
 * are stored in the {@link net.ssehub.easy.varModel.confModel.IDecisionVariable}s via the
 * {@link AdaptiveConfiguration#takeOverValues()} method.
 * @author El-Sharkawy
 */
public abstract class AbstractVariableIdentifier<V> {
    
    /**
     * Creates an ID bases on the handled element type.
     * @param variable An element, which represents an {@link net.ssehub.easy.varModel.confModel.IDecisionVariable}
     * @return A unique ID for the given variable, must return the same ID for the same variable as the
     * {@link #iDecisionVariableToID(IDecisionVariable)} method.
     * @see #iDecisionVariableToID(IDecisionVariable)
     */
    protected abstract String variableToID(V variable);
    
    /**
     * Specifies whether the ID points to a nested elements (of a compound).
     * @param id The ID to check (created via the {@link #variableToID(Object)} method).
     * @return <code>true</code> if the ID indicates a nested element, <code>false</code> if it indicates a top 
     * level variable.
     */
    protected abstract boolean isNestedVariable(String id);
    
    /**
     * Returns an iterator to iterate through toplevel and nested variables based on the given ID. <br>
     * The first ID points to the top level variable, all succeeding IDs points to the nested variable. <br>
     * This is only necessary for nested variables ({@link #isNestedVariable(String)} returns <code>true</code>).
     * @param id An ID pointing to a nested variable.
     * @return An iterator which will return: <code>&lt;ID for toplevel variable&gt; &lt;Variable nested in toplevel&gt;
     * &lt;Variable nested in layer 2&gt; ... </code>
     * @see #isNestedVariable(String)
     */
    protected abstract Iterator<String> getIDIterator(final String id);
    
    /**
     * Returns an ID for an {@link IDecisionVariable} of the configuration. Must be the same ID as generated by the
     * {@link #variableToID(Object)} method.
     * @param variable A variable of the configuration for which the ID shall be generated.
     * @return The same ID as generated by the {@link #variableToID(Object)} method.
     * @see #variableToID(Object)
     */
    protected abstract String iDecisionVariableToID(IDecisionVariable variable);
    
    /**
     * Converts the given object to an IVML value depending on the target {@link IDecisionVariable}.
     * @param trgVariable The variable for which the value shall be converted.
     * @param oValue The object value, which shall be converted.
     * @return The converted value.
     * @throws ValueDoesNotMatchTypeException If the passed object value does not match to the type of the target
     *     variable.
     */
    protected abstract Value toIVMLValue(IDecisionVariable trgVariable, Object oValue)
        throws ValueDoesNotMatchTypeException;
    
    /**
     * Allows an initial mapping values based on the id.
     * 
     * @param id the ID
     * @param oValue the value provided by the input mapping
     * @return the mapped value (here, {@code oValue})
     */
    protected Object mapValue(String id, Object oValue) {
        return oValue;
    }
    
    /**
     * Allows mapping variables to runtime clones. The ID is calculated for 
     * the original variable but if this method returns a different variable, associated
     * with the returned variable.
     * 
     * @param variable the variable to be mapped
     * @return the mapped variable (here, {@code variable})
     */
    protected IDecisionVariable mapVariable(IDecisionVariable variable) {
        return variable;
    }

    /**
     * Assigns the given value to the specified variable. Maybe overwritten by sub classes.
     * @param variable The variable for which the value shall be assigned to.
     * @param value The new value to be assigned.
     * @throws ConfigurationException ConfigurationException in case that the types of 
     *   the underlying variable and <code>value</code> do not comply
     */
    protected void assignValue(IDecisionVariable variable, Value value) throws ConfigurationException {
        variable.setValue(value, getAssignmentState());
    }
    
    /**
     * Returns the assignment state to be used.
     * 
     * @return the assignment state
     */
    protected AssignmentState getAssignmentState() {
        return AssignmentState.ASSIGNED;
    }
    
}
