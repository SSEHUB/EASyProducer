package iip.nodes;

import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Predicate;

import de.iip_ecosphere.platform.connectors.ConnectorParameter;
import de.iip_ecosphere.platform.connectors.modbustcpipv1.ModbusTcpIpConnector;
import de.iip_ecosphere.platform.services.environment.DataMapper.BaseDataUnit;
import de.iip_ecosphere.platform.services.environment.IipStringStyle;
import de.iip_ecosphere.platform.support.iip_aas.ActiveAasBase;
import de.iip_ecosphere.platform.support.iip_aas.ActiveAasBase.NotificationMode;
import de.iip_ecosphere.platform.transport.connectors.ReceptionCallback;
import de.iip_ecosphere.platform.transport.serialization.SerializerRegistry;

import iip.datatypes.ModbusSiemensRwSentron;
import iip.datatypes.ModbusSiemensRwSentronImpl;
import iip.datatypes.ModbusSiemensSentron;
import iip.serializers.AvaMqttOutputImplSerializer;
import iip.serializers.AvaMqttOutputSerializer;
import iip.serializers.MipMqttInputImplSerializer;
import iip.serializers.MipMqttInputSerializer;
import iip.serializers.MipMqttOutputImplSerializer;
import iip.serializers.MipMqttOutputSerializer;
import iip.serializers.ModbusPhoenixEEMImplSerializer;
import iip.serializers.ModbusPhoenixEEMSerializer;
import iip.serializers.ModbusPhoenixRwEEMImplSerializer;
import iip.serializers.ModbusPhoenixRwEEMSerializer;
import iip.serializers.ModbusSiemensRwSentronImplSerializer;
import iip.serializers.ModbusSiemensRwSentronSerializer;
import iip.serializers.ModbusSiemensSentronImplSerializer;
import iip.serializers.ModbusSiemensSentronSerializer;

import org.apache.commons.lang3.builder.ReflectionToStringBuilder;
import org.hamcrest.core.IsAnything;
import org.junit.Test;
import static org.junit.Assert.assertTrue;

/**
 * Implements tests for "MyModbusSentronConnExample". The generated class is meant to be re-usable and extensible, e.g., 
 * regarding the assert predicates. We provide a main method to ease startup. 
 * The connector test directly approaches the configured connector, i.e., the addressed device or server must be 
 * accessible. The command line parameter {@code --iip.test.samplingTime=t} can specify the time <i>t</i> in ms the
 * connector will do sampling during the test (default <i>t</i>=10000).
 * Generated by: EASy-Producer.
 */
public class MyModbusSentronConnExampleTest {

    private Map<Class<?>, Integer> received = new HashMap<>();
    private static String[] cmdArgs = new String[0];
    
    /**
    * Represents all potential inputs to the service and the JSON input format.
    */
    public static class DataUnit extends BaseDataUnit {
    
        private ModbusSiemensRwSentronImpl modbusSiemensRwSentron;
    
        /**
        * Returns the value of modbusSiemensRwSentron.
        *
        * @return the value of modbusSiemensRwSentron, may be <b>null</b>
        */
        public ModbusSiemensRwSentronImpl getModbusSiemensRwSentron() {
            return modbusSiemensRwSentron;
        }
        
        /**
        * Changes the value of modbusSiemensRwSentron. [required by Jackson]
        *
        * @param modbusSiemensRwSentron the new value, may be <b>null</b>
        */
        public void setModbusSiemensRwSentron(ModbusSiemensRwSentronImpl modbusSiemensRwSentron) {
            this.modbusSiemensRwSentron = modbusSiemensRwSentron;
        }
        
        @Override
        public String toString() {
            return ReflectionToStringBuilder.toString(this, IipStringStyle.SHORT_STRING_STYLE);
        }
        
    }
    
    /**
    * A predicate-based matcher for spring-based output testing. Class generated here, because we do not want to include
    * the testing artifact of services.environment and hamcrest shall not be a major production dependency.
    */
    private class TestMatcher extends IsAnything<Object> {
    
        private Map<Class<?>, Predicate<?>> predicates = new HashMap<>();
    
        /**
        * Creates an instance.
        */
        public TestMatcher() {
            super("myModbusSentronConn matcher");
        }
        
        /**
        * Adds a predicate for a given type.
        * 
        * @param <T> the type of data to be considered by the predicate
        * @param cls the type to add the predicate for
        * @param pred the predicate
        */
        private <T> void addPredicate(Class<T> cls, Predicate<T> pred) {
            predicates.put(cls, pred);
        }
    
        @Override
        public boolean matches(Object obj) {
            return test(obj);
        }
        
        /**
        * Does a typed test against {@link #predicates}.
        *
        * @param <T> the type of data to be considered by the test
        * @param obj the data/object to be tested
        * @return whether {@code obj} matches the condition of a registered predicate or {@code true} if none was 
        *     registered
        */
        private <T> boolean test(T obj) {
            incrementReceived(obj.getClass());
            printReceivedData(obj);
            @SuppressWarnings("unchecked")
            Predicate<T> pred = (Predicate<T>) predicates.get(obj.getClass());
            return null == pred ? true : pred.test(obj);
        }
    }
    
    /**
    * Creates an instance and registers the application serializers.
    */
    public MyModbusSentronConnExampleTest() {
        SerializerRegistry.registerSerializer(AvaMqttOutputImplSerializer.class);
        SerializerRegistry.registerSerializer(AvaMqttOutputSerializer.class);
        SerializerRegistry.registerSerializer(MipMqttInputImplSerializer.class);
        SerializerRegistry.registerSerializer(MipMqttInputSerializer.class);
        SerializerRegistry.registerSerializer(MipMqttOutputImplSerializer.class);
        SerializerRegistry.registerSerializer(MipMqttOutputSerializer.class);
        SerializerRegistry.registerSerializer(ModbusPhoenixEEMImplSerializer.class);
        SerializerRegistry.registerSerializer(ModbusPhoenixEEMSerializer.class);
        SerializerRegistry.registerSerializer(ModbusPhoenixRwEEMImplSerializer.class);
        SerializerRegistry.registerSerializer(ModbusPhoenixRwEEMSerializer.class);
        SerializerRegistry.registerSerializer(ModbusSiemensRwSentronImplSerializer.class);
        SerializerRegistry.registerSerializer(ModbusSiemensRwSentronSerializer.class);
        SerializerRegistry.registerSerializer(ModbusSiemensSentronImplSerializer.class);
        SerializerRegistry.registerSerializer(ModbusSiemensSentronSerializer.class);
    }
    
    /**
    * Tests the connector.
    *
    * @param params the connector parameter to use
    * @param callback the callback to attach to the connector
    *
    * @throws IOException shall not occur
    */
    protected void testConnector(ConnectorParameter params, ReceptionCallback<ModbusSiemensSentron> callback) throws IOException {
        // disable AAS connector registration
        ActiveAasBase.setNotificationMode(NotificationMode.NONE);
        ModbusTcpIpConnector<ModbusSiemensSentron, ModbusSiemensRwSentron> conn = new ModbusTcpIpConnector<>(
            MyModbusSentronConnExample.createConnectorAdapter());
        conn.connect(params);
        conn.setReceptionCallback(callback);
        conn.request(true);
        System.out.println("Disconnecting...");
        conn.disconnect();
    }
    
    /**
    * Returns the connector parameter to be used.
    *
    * @return the connector parameter, by default as configured in the model
    */
    protected ConnectorParameter createConnectorParameter() {
        return MyModbusSentronConnExample.createConnectorParameter();
    }
    
    /**
    * Increments the received counter for the given data {@code type}.
    *
    * @param type the type to increment the counter for
    */
    private void incrementReceived(Class<?> type) {
        if (received.containsKey(type)) {
            received.put(type, received.get(type) + 1);
        } else {
            received.put(type, 1);
        }
    }
    
    /**
    * Creates/returns a predicate asserting that the received data of type ModbusSiemensSentron as output of the testing
    * object is ok (or not). Allows for overriding the test behavior with "semantic" expectations.
    *
    * @return the predicate (default: lambda function always returning {@code true})
    */ 
    protected Predicate<ModbusSiemensSentron> getAssertPredicateModbusSiemensSentron() {
        return d -> true;
    }
    
    /**
    * Returns the predicate to assert the counters for received data type instances.
    *
    * @return the predicate (by default, a predicate with constant value {@code true})
    */
    protected Predicate<Map<Class<?>, Integer>> createReceivedCounterAssertPredicate() {
        return m -> true;
    }
    
    /**
    * Prints the received data. Can be overridden.
    *
    * @param data the received data
    */
    protected void printReceivedData(Object data) {
        System.out.println(data);
    }
    
    /**
    * Returns the initial period.
    *
    * @return the initial period in ms, no (initial) input delay happens if the value is zero or negative
    */
    protected int getInitialPeriod() {
        return 500;
    } 

    /**
    * Tests the connector, here whether the connector (parameterized by {@link #createConnectorParameter()} delivered
    * any data.
    *
    * @throws IOException shall not occur / test failure
    */
    @Test
    public void testConnector() throws IOException {
        MyModbusSentronConnExampleTest test = new MyModbusSentronConnExampleTest();
        AtomicInteger counter = new AtomicInteger(0);
        ReceptionCallback<ModbusSiemensSentron> callback = new ReceptionCallback<ModbusSiemensSentron>() {
        
            @Override
            public void received(ModbusSiemensSentron data) {
                counter.incrementAndGet();
                printReceivedData(data);
                incrementReceived(ModbusSiemensSentron.class);
            }
            
            @Override
            public Class<ModbusSiemensSentron> getType() {
                return ModbusSiemensSentron.class;
            }
            
        };
        test.testConnector(test.createConnectorParameter(), callback);
        assertTrue("Connector does not deliver data", counter.get() > 0);
        assertTrue("Received counters not as expected", createReceivedCounterAssertPredicate().test(Collections.
            unmodifiableMap(received)));
    }
    
    
    /**
    * Starts the configured version of this service/connector as main program.
    *
    * @param args command line arguments
    * 
    * @throws IOException shall not occur
    */
    public static void main(String[] args) throws IOException {
        cmdArgs = args;
        MyModbusSentronConnExampleTest test = new MyModbusSentronConnExampleTest();
        ReceptionCallback<ModbusSiemensSentron> callback = new ReceptionCallback<ModbusSiemensSentron>() {
        
            @Override
            public void received(ModbusSiemensSentron data) {
                System.out.println(data);
            }
            
            @Override
            public Class<ModbusSiemensSentron> getType() {
                return ModbusSiemensSentron.class;
            }
            
        };
        test.testConnector(test.createConnectorParameter(), callback);
        System.exit(0);
    }

}
